import type { CID } from 'multiformats/cid';
import type { Observable } from 'rxjs';
import type { AnchorProof, AnchorStatus } from './stream.js';
import type { CeramicApi } from './ceramic-api.js';
import type { FetchRequest } from './utils/http-utils.js';
import type { StreamID } from '@ceramicnetwork/streamid';
export declare enum AnchorServiceAuthMethods {
    DID = "did"
}
export interface AnchorServicePending {
    readonly status: AnchorStatus.PENDING;
    readonly streamId: StreamID;
    readonly cid: CID;
    readonly message: string;
}
export interface AnchorServiceProcessing {
    readonly status: AnchorStatus.PROCESSING;
    readonly streamId: StreamID;
    readonly cid: CID;
    readonly message: string;
}
export interface AnchorServiceAnchored {
    readonly status: AnchorStatus.ANCHORED;
    readonly streamId: StreamID;
    readonly cid: CID;
    readonly message: string;
    readonly anchorCommit: CID;
}
export interface AnchorServiceFailed {
    readonly status: AnchorStatus.FAILED;
    readonly streamId: StreamID;
    readonly cid: CID;
    readonly message: string;
}
export interface AnchorServiceReplaced {
    readonly status: AnchorStatus.REPLACED;
    readonly streamId: StreamID;
    readonly cid: CID;
    readonly message: string;
}
export declare type RequestAnchorParams = {
    streamID: StreamID;
    tip: CID;
    timestampISO: string;
};
export declare type AnchorServiceResponse = AnchorServicePending | AnchorServiceProcessing | AnchorServiceAnchored | AnchorServiceFailed | AnchorServiceReplaced;
export interface AnchorService {
    init(): Promise<void>;
    ceramic: CeramicApi;
    url: string;
    requestAnchor(params: RequestAnchorParams): Observable<AnchorServiceResponse>;
    pollForAnchorResponse(streamId: StreamID, tip: CID): Observable<AnchorServiceResponse>;
    getSupportedChains(): Promise<Array<string>>;
}
export interface AuthenticatedAnchorService extends AnchorService {
    auth: AnchorServiceAuth;
}
export interface AnchorServiceAuth {
    init(): Promise<void>;
    ceramic: CeramicApi;
    sendAuthenticatedRequest: FetchRequest;
}
export interface AnchorValidator {
    chainId: string;
    ethereumRpcEndpoint: string | null;
    init(chainId: string | null): Promise<void>;
    validateChainInclusion(anchorProof: AnchorProof): Promise<number>;
}
//# sourceMappingURL=anchor-service.d.ts.map
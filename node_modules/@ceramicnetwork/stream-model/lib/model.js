var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Model_1;
import { Stream, StreamStatic, SyncOptions, } from '@ceramicnetwork/common';
import { StreamID, StreamRef } from '@ceramicnetwork/streamid';
import { CID } from 'multiformats/cid';
import { create } from 'multiformats/hashes/digest';
import { code, encode } from '@ipld/dag-cbor';
import multihashes from 'multihashes';
export const MODEL_VERSION_REGEXP = /^[0-9]+\.[0-9]+$/;
export function parseModelVersion(version) {
    if (!MODEL_VERSION_REGEXP.test(version)) {
        throw new Error(`Unsupported version format: ${version}`);
    }
    const [major, minor] = version.split('.').map((part) => parseInt(part, 10));
    return [major, minor];
}
const DEFAULT_LOAD_OPTS = { sync: SyncOptions.PREFER_CACHE };
async function _ensureAuthenticated(signer) {
    if (signer.did == null) {
        throw new Error('No DID provided');
    }
    if (!signer.did.authenticated) {
        await signer.did.authenticate();
        if (signer.loggerProvider) {
            signer.loggerProvider.getDiagnosticsLogger().imp(`Now authenticated as DID ${signer.did.id}`);
        }
    }
}
async function throwReadOnlyError() {
    throw new Error('Historical stream commits cannot be modified. Load the stream without specifying a commit to make updates.');
}
let Model = Model_1 = class Model extends Stream {
    constructor() {
        super(...arguments);
        this._isReadOnly = false;
    }
    get content() {
        return super.content;
    }
    get metadata() {
        return { controller: this.state$.value.metadata.controllers[0], model: Model_1.MODEL };
    }
    static async create(ceramic, content, metadata) {
        Model_1.assertComplete(content);
        Model_1.assertVersionValid(content, 'minor');
        Model_1.assertRelationsValid(content);
        const opts = {
            publish: true,
            anchor: true,
            sync: SyncOptions.NEVER_SYNC,
        };
        const commit = await Model_1._makeGenesis(ceramic, content, metadata);
        const model = await ceramic.createStreamFromGenesis(Model_1.STREAM_TYPE_ID, commit, opts);
        return model;
    }
    static assertComplete(content, streamId) {
        if (!content.name) {
            if (streamId) {
                throw new Error(`Model with StreamID ${streamId.toString()} is missing a 'name' field`);
            }
            else {
                throw new Error(`Model is missing a 'name' field`);
            }
        }
        if (!content.version) {
            if (streamId) {
                throw new Error(`Model ${content.name} (${streamId.toString()}) is missing a 'version' field`);
            }
            else {
                throw new Error(`Model ${content.name} is missing a 'version' field`);
            }
        }
        if (!content.schema) {
            if (streamId) {
                throw new Error(`Model ${content.name} (${streamId.toString()}) is missing a 'schema' field`);
            }
            else {
                throw new Error(`Model ${content.name} is missing a 'schema' field`);
            }
        }
        if (!content.accountRelation) {
            if (streamId) {
                throw new Error(`Model ${content.name} (${streamId.toString()}) is missing a 'accountRelation' field`);
            }
            else {
                throw new Error(`Model ${content.name} is missing a 'accountRelation' field`);
            }
        }
    }
    static assertVersionValid(content, satisfies = 'minor') {
        const [expectedMajor, expectedMinor] = parseModelVersion(Model_1.VERSION);
        const [major, minor] = parseModelVersion(content.version);
        if (major > expectedMajor ||
            (satisfies === 'minor' && major === expectedMajor && minor > expectedMinor)) {
            throw new Error(`Unsupported version ${content.version} for model ${content.name}, the maximum version supported by the Ceramic node is ${Model_1.VERSION}. Please update your Ceramic node to a newer version supporting at least version ${content.version} of the Model definition.`);
        }
    }
    static assertRelationsValid(content) {
        if (!content.relations) {
            return;
        }
        for (const [fieldName, relationDefinition] of Object.entries(content.relations)) {
            switch (relationDefinition.type) {
                case 'account':
                    continue;
                case 'document':
                    try {
                        StreamID.fromString(relationDefinition.model);
                    }
                    catch (err) {
                        throw new Error(`Relation on field ${fieldName} has invalid model: ${err.toString()}`);
                    }
                    continue;
                default:
                    throw new Error(`Relation on field ${fieldName} has unexpected type ${relationDefinition.type}`);
            }
        }
    }
    static async load(ceramic, streamId, opts = {}) {
        opts = { ...DEFAULT_LOAD_OPTS, ...opts };
        const streamRef = StreamRef.from(streamId);
        if (streamRef.type != Model_1.STREAM_TYPE_ID) {
            throw new Error(`StreamID ${streamRef.toString()} does not refer to a '${Model_1.STREAM_TYPE_NAME}' stream, but to a ${streamRef.typeName}`);
        }
        const model = await ceramic.loadStream(streamRef, opts);
        return model;
    }
    static async _makeGenesis(signer, content, metadata) {
        const commit = await this._makeRawGenesis(signer, content, metadata);
        return Model_1._signDagJWS(signer, commit);
    }
    static async _makeRawGenesis(signer, content, metadata) {
        if (content == null) {
            throw new Error(`Genesis content cannot be null`);
        }
        if (!metadata || !metadata.controller) {
            if (signer.did) {
                await _ensureAuthenticated(signer);
                metadata = { controller: signer.did.hasParent ? signer.did.parent : signer.did.id };
            }
            else {
                throw new Error('No controller specified');
            }
        }
        const header = {
            controllers: [metadata.controller],
            model: Model_1.MODEL.bytes,
            sep: 'model',
        };
        return { data: content, header };
    }
    makeReadOnly() {
        this.sync = throwReadOnlyError;
        this._isReadOnly = true;
    }
    get isReadOnly() {
        return this._isReadOnly;
    }
    static async _signDagJWS(signer, commit) {
        await _ensureAuthenticated(signer);
        return signer.did.createDagJWS(commit);
    }
};
Model.STREAM_TYPE_NAME = 'model';
Model.STREAM_TYPE_ID = 2;
Model.MODEL = (function () {
    const data = encode('model-v1');
    const multihash = multihashes.encode(data, 'identity');
    const digest = create(code, multihash);
    const cid = CID.createV1(code, digest);
    return new StreamID('UNLOADABLE', cid);
})();
Model.VERSION = '1.0';
Model = Model_1 = __decorate([
    StreamStatic()
], Model);
export { Model };
//# sourceMappingURL=model.js.map